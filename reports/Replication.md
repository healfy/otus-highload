# Отчет по заданию 3 (Репликация)

## Настройка репликации

Созданы 2 виртуальные машины, на них установлен mysql-server.

#### Конфигурация mysql для мастера:

```yaml
bind-address = *
server-id = 1
log_bin = /var/log/mysql/mysql-bin.log
binlog_do_db = otus
```

#### Конфигурация mysql для слейва:

```yaml
server-id = 2
relay-log = /var/log/mysql/mysql-relay-bin.log
log_bin = /var/log/mysql/mysql-bin.log
binlog_do_db = newdatabase
```

#### Команды, выполняемые на мастере:

```sql
GRANT REPLICATION SLAVE ON *.* TO 'slave'@'%' IDENTIFIED BY 'password';
```

#### Команды, выполняемые на слейве:

```sql
CHANGE MASTER TO
    MASTER_HOST ='host',
    MASTER_USER ='slave',
    MASTER_PASSWORD ='password',
    MASTER_LOG_FILE ='mysql-bin.000001',
    MASTER_LOG_POS = 999;
START SLAVE;
```

## Изменения в приложении

Все запросы на чтение перенесены на чтение со слейвов. (Исключение — запросы, в которых выполняются запись, и
последующее чтение записанных данных - я понимаю, что это антипаттерн, в рамках выполнения задания не исправлял эту
проблему).

В конфигурацию приложения добавлен опциональный параметр `SLAVE_DATABASES` - список настроек для подключения к слейвам.
При старте приложения создаются коннекторы, в случае если запрос на чтение, а этот список не пустой - вместо чтения с
мастера будет выполнено чтение с произвольного слейва (round-robin).

## Тестирование нагрузки

#### Запрос

Для тестирования используется утилита wrk.

##### Параметры:

* Число подключений - 100
* Время теста 1 минута
* Запрос — список пользователей с именем "Роберт" (в базе на 1 000 000 пользователей таких 1 964, пагинацией ограничено
  до 100).

`wrk -c100 -t1 -d1m --timeout 5s "http://localhost:8000/api/v1/users/?first_name=%D0%A0%D0%BE%D0%B1%D0%B5%D1%80%D1%82"`

| Репликация  | CPU% | MEM% | IO% | Load Average |
|:------------- |:---------------:| -------------:| -------------: | -------------: |
| Выключена | 21.2 | 22.3 | 19.1 | 1.31 |
| Включена | 0.3 | 25.3 | 0.0 | 0.02 |

## Проверка потери транзакций при полусинхронной репликации

### Включение Row-based репликации

Мастер и слейв останавливаются, в конфигурационный файл добавляется:
`binlog_format = ROW`

### Включение GTID

Мастер и слейв останавливаются, в конфигурационный файл добавляется:
```yaml
gtid_mode=ON
enforce-gtid-consistency
replicate-do-db = otus
```

### Настройка полусинхронной репликации

На мастере нужно установить плагин:
```sql
INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
```
И изменить конфигурацию:
```yaml
rpl_semi_sync_master_enabled = 1
```
На слейве установить плагин:
```sql
INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so'
```
И изменить конфигурацию:
```yaml
rpl_semi_sync_slave_enabled = 1
```
### Проверка потери транзакций при полусинхронной репликации

Для проверки был использован скрипт:
[Скрипт](../social_network/db/fill_database/create_hobbies.py)

В процессе работы скрипта на мастере убивался процесс mysqld.
Затем слейв промоутился до мастера, второй слейв переключался на него.
Сравнивалось число строк, полученных из скрипта с числом строк на слейве.

По результатам нескольких тестов потерь транзакций не обнаружено.
